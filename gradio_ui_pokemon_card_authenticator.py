# -*- coding: utf-8 -*-
"""gradio-ui-pokemon-card-authenticator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PfMek8tf9Ztk5QCiorsFU3fMiUNQNnGn

# Introduction #

Thanks to Kaggle mini-courses on computer vision for getting me started on this.
My first trained CNN to classify the card images heavily inspired by Francesco Marazz's CNN (https://www.kaggle.com/fmarazzi/baseline-keras-cnn-roc-fast-10min-0-925-lb) for the Histopathologic Cancer Detection competition (https://www.kaggle.com/c/histopathologic-cancer-detection).

My objective here is to build my first image classifier using Keras. Rare Pokemon cards are highly sought after by collectors, with some even reaching re-sale prices of hundreds of thousands of dollars. It would be important for collectors to tell a genuine card from fake card to avoid getting duped. Experienced collectors are able to tell the different between a genuine and fake card by looking at the features of the back of the card alone, but this might not be so obvious for newcomers. The image classifier described below will aim to classify, with high accuracy (>95%), Pokemon cards as genuine or fake based on the back visuals of the card alone. In future work, the model can be made more robust by including more counterfeit variations, folded, torn, new and old cards in the training, validation and test sets.

# Preprocess Image
User should upload a landscape image with the Pokemon card image positioned upright in the centre of the photo
"""

import cv2
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from PIL import Image
import tensorflow as tf 
import numpy as np
from tensorflow.keras.models import load_model

def readImage(path):
    # OpenCV reads the image in bgr format by default
    bgr_img = cv2.imread(path)
    # We flip it to rgb for visualization purposes
    b,g,r = cv2.split(bgr_img)
    rgb_img = cv2.merge([r,g,b])
    return rgb_img

def crop_center(img):
    y,x,z = img.shape
    startx = (x-y)//2
    starty = 0
    return img[starty:y,startx:startx+y]

def resizeImage(img):
    r = 256.0 / img.shape[0]
    dim = (int(img.shape[1] * r), 256)
    resized = cv2.resize(img, dim, interpolation = cv2.INTER_AREA)
    return resized

model = load_model("/content/drive/MyDrive/Colab Notebooks/pkm_card.h5")

"""# Define function"""

def pkm_predict(image):
    image = crop_center(image)
    print(image.shape)
    image = resizeImage(image)
    print(image.shape)
    K_test = (image - image.mean()) / image.std()
    print(image.shape)
    K_test = np.reshape(K_test, (1, 256, 256, 3)) 
    predictions = model.predict(K_test)
    print(predictions)
    predictions = list(map(lambda x: 0 if x<0.5 else 1, predictions)) # get binary values predictions with 0.5 as thresold
    print(predictions)
    if predictions == [1]:
        return "This card is likely genuine." 
    else:
        return "This card is likely counterfeit."

"""# Install Gradio #"""

!pip install -q gradio

import gradio as gr
image = gr.inputs.Image()

iface= gr.Interface(
    fn=pkm_predict,
    inputs=image,
    outputs="text",
)

iface.launch()